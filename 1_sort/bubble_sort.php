<?php
/**
 * 冒泡排序
 * 原理就是将相邻的两两比较，将最大的/最小的移动到最边缘
 * 然后继续两两比较除边缘外的值，这样循环n-1次后就排序完成了
 * 时间复杂度O(N^2),很费时。是稳定排序
 *
 */
error_reporting(E_ALL & ~E_NOTICE);
//输入总个数
echo 'please input total number:';
$num = intval(fgets(STDIN));
$a = [];
//输入名称和分数，中间空格分割
for ($i = 0; $i < $num; $i++) {//下标从0开始
    printf("please input name and score:");
    $input = fgets(STDIN);
    list($name, $score) = explode(' ', $input);
    //为了能展示名字，用二维数组存储来存储，否则可以直接用一维数组只存储分数
    $a[$i]['score'] = floatval($score);//必须转为数组，否则按照字符串来排序
    $a[$i]['name'] = $name;
}
$t = [];
//开始冒泡排序(从大到小)
for ($i = 0; $i < $num - 1; $i++) {//如果有5个数，则只比较4此就可以
    //每次$j循环，将两个相邻的比较，最终将最小放在了最后面,然后继续$i循环，并且下次$i循环中的$j循环不用管最后的了，因为最小的已经放在最后了，所以$j<$num-$i
    for ($j = 0; $j < $num - $i; $j++) {
        if ($a[$j]['score'] < $a[$j + 1]['score']) {
            $t = $a[$j];
            $a[$j] = $a[$j + 1];
            $a[$j + 1] = $t;
        }
    }
}

//另一种排序方法：选择排序(从大到小)，时间复杂度同样是O(N^2),但是交换次数概率减少了，效率比冒泡可能好点，但也相差无几，但逻辑上来说更加直观，是非稳定性排序
// for($i=0;$i<$num;$i++){
// 	for($j=$i+1;$j<$num;$j++){
// 		if($a[$i]['score']<$a[$j]['score']){
// 			$t=$a[$i];
// 			$a[$i]=$a[$j];
// 			$a[$j]=$t;
// 		}
// 	}
// }

//另一种排序方法：直接插入排序（从大到小），这个对原有排序很敏感，最好时间复杂度为O(N)，最差时间复杂度还是O(N^2)，是稳定性排序
// for($i=1;$i<=$num;$i++){//从第二个开始
// 	if($a[$i]['score']>$a[$i-1]['score']){//如果这个数比前一个数大，则需要插入
// 		$t=$a[$i];//先将此数存储为临时数组
// 		//如果小于临时数组的值，则将其下标后移
// 		for($j=$i-1;$j>=0&&$a[$j]['score']<$t['score'];$j--){
// 			$a[$j+1]=$a[$j];
// 		}
// 		$a[$j+1]=$t;//下标全部移动完成后，将其值插入，由于执行完上方for后$j--又减少了，所以这里$j+1才是正确的插入位置
// 	}
// }

//输出名字及分数
for ($i = 0; $i < $num; $i++) {
    echo $a[$i]['name'] . ' ' . $a[$i]['score'] . "\n";
}